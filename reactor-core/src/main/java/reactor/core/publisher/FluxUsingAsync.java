/*
 * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package reactor.core.publisher;

import java.util.Objects;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.function.Function;
import java.util.function.Supplier;

import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import reactor.core.CoreSubscriber;
import reactor.core.Exceptions;
import reactor.core.Fuseable;
import reactor.util.Logger;
import reactor.util.Loggers;
import reactor.util.annotation.Nullable;

/**
 * Uses a resource, generated by a supplier for each individual {@link Subscriber},
 * while streaming the values from a {@link Publisher} derived from the same resource.
 * Whenever the resulting sequence terminates, the relevant {@link Function} generates
 * a "cleanup" {@link Publisher} that is invoked but doesn't change the content of the
 * main sequence. Instead it just defers the termination (unless it errors, in which case
 * the error suppresses the original termination signal).
 *
 * @param <T> the value type streamed
 * @param <S> the resource type
 */
final class FluxUsingAsync<T, S> extends Flux<T> implements Fuseable, SourceProducer<T> {

	final Supplier<S>                                           resourceSupplier;
	final Function<? super S, ? extends Publisher<? extends T>> resourceClosure;
	final Function<? super S, ? extends Publisher<?>>           asyncComplete;
	final Function<? super S, ? extends Publisher<?>>           asyncError;
	@Nullable
	final Function<? super S, ? extends Publisher<?>>           asyncCancel;

	FluxUsingAsync(Supplier<S> resourceSupplier,
			Function<? super S, ? extends Publisher<? extends T>> resourceClosure,
			Function<? super S, ? extends Publisher<?>> asyncComplete,
			Function<? super S, ? extends Publisher<?>> asyncError,
			@Nullable Function<? super S, ? extends Publisher<?>> asyncCancel) {
		this.resourceSupplier = Objects.requireNonNull(resourceSupplier, "resourceSupplier");
		this.resourceClosure = Objects.requireNonNull(resourceClosure, "resourceClosure");
		this.asyncComplete = Objects.requireNonNull(asyncComplete, "asyncComplete");
		this.asyncError = Objects.requireNonNull(asyncError, "asyncError");
		this.asyncCancel = asyncCancel;
	}

	@Override
	@SuppressWarnings("unchecked")
	public void subscribe(CoreSubscriber<? super T> actual) {
		S resource;

		try {
			resource = Objects.requireNonNull(resourceSupplier.get(),
					"The resourceSupplier returned a null value");
		}
		catch (Throwable e) {
			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
			return;
		}

		Publisher<? extends T> p;

		try {
			p = Objects.requireNonNull(resourceClosure.apply(resource),
					"The resourceClosure function returned a null value");
		}
		catch (Throwable e) {
			//TODO should a closure#apply error translate to a asyncError? (for now it will)
			p = Mono.error(e);
		}

		if (p instanceof Fuseable) {
			from(p).subscribe(new UsingAsyncFuseableSubscriber<>(actual,
					resource, asyncComplete, asyncError, asyncCancel));
		}
		else if (actual instanceof ConditionalSubscriber) {
			from(p).subscribe(new UsingAsyncConditionalSubscriber<>((ConditionalSubscriber<? super T>) actual,
					resource, asyncComplete, asyncError, asyncCancel));
		}
		else {
			from(p).subscribe(new UsingAsyncSubscriber<>(actual, resource, asyncComplete, asyncError, asyncCancel));
		}
	}

	@Override
	public Object scanUnsafe(Attr key) {
		return null; //no particular key to be represented, still useful in hooks
	}

	static class UsingAsyncSubscriber<T, S> implements InnerOperator<T, T>,
	                                                   QueueSubscription<T> {

		//state that differs in the different variants
		final CoreSubscriber<? super T>                   actual;
		volatile Subscription                             s;
		static final AtomicReferenceFieldUpdater<UsingAsyncSubscriber, Subscription>SUBSCRIPTION =
				AtomicReferenceFieldUpdater.newUpdater(UsingAsyncSubscriber.class,
						Subscription.class, "s");

		//rest of the state is always the same
		final S                                           resource;
		final Function<? super S, ? extends Publisher<?>> asyncComplete;
		final Function<? super S, ? extends Publisher<?>> asyncError;
		@Nullable
		final Function<? super S, ? extends Publisher<?>> asyncCancel;

		volatile int                                                 wip;
		static final AtomicIntegerFieldUpdater<UsingAsyncSubscriber> WIP =
				AtomicIntegerFieldUpdater.newUpdater(UsingAsyncSubscriber.class, "wip");

		UsingAsyncSubscriber(CoreSubscriber<? super T> actual,
				S resource,
				Function<? super S, ? extends Publisher<?>> asyncComplete,
				Function<? super S, ? extends Publisher<?>> asyncError,
				@Nullable Function<? super S, ? extends Publisher<?>> asyncCancel) {
			this.actual = actual;
			this.resource = resource;
			this.asyncComplete = asyncComplete;
			this.asyncError = asyncError;
			this.asyncCancel = asyncCancel;
		}

		@Override
		public CoreSubscriber<? super T> actual() {
			return this.actual;
		}

		@Nullable
		public Object scanUnsafe(Attr key) {
			if (key == Attr.TERMINATED || key == Attr.CANCELLED) return wip == 1;
			if (key == Attr.PARENT) return s;

			return InnerOperator.super.scanUnsafe(key);
		}

		@Override
		public void request(long l) {
			if (Operators.validate(l)) {
				s.request(l);
			}
		}

		@Override
		public void cancel() {
			if (Operators.terminate(SUBSCRIPTION, this)) {
				try {
					if (asyncCancel != null) {
						//FIXME better integration of asyncCancel?
						Flux.from(asyncCancel.apply(resource))
						    .subscribe(v -> {},
								error -> Loggers.getLogger(FluxUsingAsync.class).warn("Async resource cleanup failed after cancel", error));
					}
					else {
						//FIXME should there be a default to the "complete" path on cancellation, or NO-OP?
						Flux.from(asyncComplete.apply(resource))
						    .subscribe(v -> {},
								error -> Loggers.getLogger(FluxUsingAsync.class).warn("Async resource cleanup failed after cancel", error));
					}
				}
				catch (Throwable error) {
					Loggers.getLogger(FluxUsingAsync.class).warn("Error generating async resource cleanup during onCancel", error);
				}
			}
		}

		@Override
		public void onNext(T t) {
			actual.onNext(t);
		}

		@Override
		public void onError(Throwable t) {
			Publisher<?> p;

			try {
				p = Objects.requireNonNull(asyncError.apply(resource),
						"The asyncError returned a null Publisher");
			}
			catch (Throwable e) {
				Throwable _e = Operators.onOperatorError(e, actual.currentContext());
				_e = Exceptions.addSuppressed(_e, t);
				actual.onError(_e);
				return;
			}

			p.subscribe(new RollbackInner(this, t));
		}

		@Override
		public void onComplete() {
			Publisher<?> p;

			try {
				p = Objects.requireNonNull(asyncComplete.apply(resource),
						"The asyncComplete returned a null Publisher");
			}
			catch (Throwable e) {
				Throwable _e = Operators.onOperatorError(e, actual.currentContext());
				actual.onError(_e);
				return;
			}

			p.subscribe(new CommitInner(this));
		}

		// below methods have changes in the different implementations

		@Override
		public void onSubscribe(Subscription s) {
			if (Operators.validate(this.s, s)) {
				this.s = s;
				actual.onSubscribe(this);
			}
		}

		@Override
		public int requestFusion(int requestedMode) {
			return NONE; // always reject, upstream turned out to be non-fuseable after all
		}

		@Override
		public void clear() {
			// ignoring fusion methods
		}

		@Override
		public boolean isEmpty() {
			// ignoring fusion methods
			return true;
		}

		@Override
		@Nullable
		public T poll() {
			return null;
		}

		@Override
		public int size() {
			return 0;
		}
	}

	static final class UsingAsyncConditionalSubscriber<T, S>
			extends UsingAsyncSubscriber<T, S>
			implements ConditionalSubscriber<T> {

		final ConditionalSubscriber<? super T>            actual;

		UsingAsyncConditionalSubscriber(ConditionalSubscriber<? super T> actual,
				S resource,
				Function<? super S, ? extends Publisher<?>> asyncComplete,
				Function<? super S, ? extends Publisher<?>> asyncError,
				@Nullable Function<? super S, ? extends Publisher<?>> asyncCancel) {
			super(actual, resource, asyncComplete, asyncError, asyncCancel);
			this.actual = actual;
		}

		@Override
		public boolean tryOnNext(T t) {
			return actual.tryOnNext(t);
		}
	}

	static final class UsingAsyncFuseableSubscriber<T, S> implements InnerOperator<T, T>,
	                                                                 QueueSubscription<T> {

		//state that differs in the different variants
		int mode;
		final CoreSubscriber<? super T>                   actual;
		volatile     QueueSubscription<T> qs;
		static final AtomicReferenceFieldUpdater<UsingAsyncFuseableSubscriber, QueueSubscription> SUBSCRIPTION =
				AtomicReferenceFieldUpdater.newUpdater(UsingAsyncFuseableSubscriber.class,
						QueueSubscription.class, "qs");

		//rest of the state is same as UsingAsyncSubscriber
		final S                                           resource;
		final Function<? super S, ? extends Publisher<?>> asyncComplete;
		final Function<? super S, ? extends Publisher<?>> asyncError;
		@Nullable
		final Function<? super S, ? extends Publisher<?>> asyncCancel;
		volatile int                                      wip;

		static final AtomicIntegerFieldUpdater<UsingAsyncFuseableSubscriber> WIP =
				AtomicIntegerFieldUpdater.newUpdater(UsingAsyncFuseableSubscriber.class, "wip");

		UsingAsyncFuseableSubscriber(CoreSubscriber<? super T> actual,
				S resource,
				Function<? super S, ? extends Publisher<?>> asyncComplete,
				Function<? super S, ? extends Publisher<?>> asyncError,
				@Nullable Function<? super S, ? extends Publisher<?>> asyncCancel) {
			this.actual = actual;
			this.resource = resource;
			this.asyncComplete = asyncComplete;
			this.asyncError = asyncError;
			this.asyncCancel = asyncCancel;
		}

		@Override
		public CoreSubscriber<? super T> actual() {
			return this.actual;
		}

		@Nullable
		public Object scanUnsafe(Attr key) {
			if (key == Attr.TERMINATED || key == Attr.CANCELLED) return wip == 1;
			if (key == Attr.PARENT) return qs;

			return InnerOperator.super.scanUnsafe(key);
		}

		@Override
		public void request(long l) {
			if (Operators.validate(l)) {
				qs.request(l);
			}
		}

		@Override
		public void cancel() {
			QueueSubscription a = SUBSCRIPTION.get(this);
			if (a != null) {
				a = SUBSCRIPTION.getAndSet(this, null);
				if (a != null) {
					a.cancel();

					try {
						if (asyncCancel != null) {
							//FIXME better integration of asyncCancel?
							Flux.from(asyncCancel.apply(resource))
							    .subscribe(v -> {},
									    error -> Loggers.getLogger(FluxUsingAsync.class).warn("Async resource cleanup failed after cancel", error));
						}
						else {
							//FIXME should there be a default to the "complete" path on cancellation, or NO-OP?
							Flux.from(asyncComplete.apply(resource))
							    .subscribe(v -> {},
									    error -> Loggers.getLogger(FluxUsingAsync.class).warn("Async resource cleanup failed after cancel", error));
						}
					}
					catch (Throwable error) {
						Loggers.getLogger(FluxUsingAsync.class).warn("Error generating async resource cleanup during onCancel", error);
					}
				}
				//else already cancelled
			}
		}

		@Override
		public void onNext(T t) {
			actual.onNext(t);
		}

		@Override
		public void onError(Throwable t) {
			Publisher<?> p;

			try {
				p = Objects.requireNonNull(asyncError.apply(resource),
						"The asyncError returned a null Publisher");
			}
			catch (Throwable e) {
				Throwable _e = Operators.onOperatorError(e, actual.currentContext());
				_e = Exceptions.addSuppressed(_e, t);
				actual.onError(_e);
				return;
			}

			p.subscribe(new RollbackInner(this, t));
		}

		@Override
		public void onComplete() {
			Publisher<?> p;

			try {
				p = Objects.requireNonNull(asyncComplete.apply(resource),
						"The asyncComplete returned a null Publisher");
			}
			catch (Throwable e) {
				Throwable _e = Operators.onOperatorError(e, actual.currentContext());
				actual.onError(_e);
				return;
			}

			p.subscribe(new CommitInner(this));
		}

		// below are methods differing from UsingAsyncSubscriber

		@Override
		public void onSubscribe(Subscription s) {
			if (Operators.validate(this.qs, s)) {
				//noinspection unchecked
				this.qs = (QueueSubscription<T>) s;
				actual.onSubscribe(this);
			}
		}

		@Override
		public void clear() {
			qs.clear();
		}

		@Override
		public boolean isEmpty() {
			return qs.isEmpty();
		}

		@Override
		public int size() {
			return qs.size();
		}

		@Override
		@Nullable
		public T poll() {
			T v = qs.poll();

			if (v == null && mode == SYNC) {
				if (WIP.compareAndSet(this, 0, 1)) {
					Flux.from(asyncComplete.apply(resource))
					    .subscribe(it -> {},
							    e -> Loggers.getLogger(FluxUsingAsync.class).warn("Async resource cleanup failed after poll", e));
				}
			}
			return v;
		}

		@Override
		public int requestFusion(int requestedMode) {
			int m = qs.requestFusion(requestedMode);
			this.mode = m;
			return m;
		}
	}

	static final class RollbackInner implements InnerConsumer<Object> {

		final InnerOperator        parent;
		final Throwable            rollbackCause;

		RollbackInner(InnerOperator ts, Throwable rollbackCause) {
			this.parent = ts;
			this.rollbackCause = rollbackCause;
		}

		@Override
		public void onSubscribe(Subscription s) {
			Objects.requireNonNull(s, "Subscription cannot be null")
			       .request(Long.MAX_VALUE);
		}

		@Override
		public void onNext(Object o) {
			//NO-OP
		}

		@Override
		public void onError(Throwable e) {
			RuntimeException rollbackError = new RuntimeException("Async resource cleanup failed after onError", e);
			parent.actual().onError(Exceptions.addSuppressed(rollbackError, rollbackCause));
		}

		@Override
		public void onComplete() {
			parent.actual().onError(rollbackCause);
		}

		@Override
		public Object scanUnsafe(Attr key) {
			if (key == Attr.PARENT) return parent;
			if (key == Attr.ACTUAL) return parent.actual();
			if (key == Attr.ERROR) return rollbackCause;

			return null;
		}
	}

	static final class CommitInner implements InnerConsumer<Object> {

		final InnerOperator parent;

		CommitInner(InnerOperator ts) {
			this.parent = ts;
		}

		@Override
		public void onSubscribe(Subscription s) {
			Objects.requireNonNull(s, "Subscription cannot be null")
			       .request(Long.MAX_VALUE);
		}

		@Override
		public void onNext(Object o) {
			//NO-OP
		}

		@Override
		public void onError(Throwable e) {
			Throwable e_ = Operators.onOperatorError(e, parent.actual().currentContext());
			Throwable commitError = new RuntimeException("Async resource cleanup failed after onComplete", e_);
			parent.actual().onError(commitError);
		}

		@Override
		public void onComplete() {
			parent.actual().onComplete();
		}

		@Override
		public Object scanUnsafe(Attr key) {
			if (key == Attr.PARENT) return parent;
			if (key == Attr.ACTUAL) return parent.actual();

			return null;
		}
	}
}
